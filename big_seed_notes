 
STORE:
	Add animation on storeowner question

PRUNE:
	possible fruits on plant? match number?
	FRUITS ARE ALL ON THE GROUND -> that way need not place on plant itself


EVOLVE:
	poke-esque flashing switch for transformation?
	or rather, smooth transition like plant growing? --> probably not, too hard


PLANT DISPLAY:
	Need mask for plants, so if click on plants, can gather fruit?
	add stats below plant
	Modify so picking which image is based on linking stage to loaded images for given plant
	--> means taking all images from auto_draw, then throwing in class definition?

PLANT CROSS:
	Track something like "health" stat secretly, and only mention when crossing plants
	Healthier plant (I.e. treated better?) has greater chance of passing along attributes
	--> so its "fitter" in this arena, and prob to choose that plant's dataset portion is higher in cross
	WILL need to save plant data somewhere on generation (pass back to main) so cross possible
	POSSIBLE: literally interlace slices of each tree? would have to avoid branches though ....
			  mix of interlacing and ... or use same algo for branch and trunk creation AND now add in leaves?
			  draw some

EVENTS:
	storm, have to treat acoordingly?
	minigame during?



use tkinter to draw things on a canvas, randomize drawings in way that makes rando plant, then come up with rules to cross two drawings ..
WILD: depends on color values that will define plant parts? ... 
draw a bunch of test plants, try to determine way to combine the drawings so as to still have a "plant" like thing that emerges
might depend on rules that define each .. actually definitely will


same seed each time, but different base, trunk, top, and branches
make smaller seed to display
howto pick places to place leaves? --> could only be at end of branches....
attributes: 
		branch: {length, location, number, color}  --> length is like num of recursive branch offs
		base: {width, height, color} --> width for circle base means radius
		trunk: {width, height, color} --> width for trunk is equal to or less than trunk
		top: {shape, color, width} --> width is equal to or less than trunk width

# bases: start with rectangle, circle, trapezoid...
# need seed -> bud -> sapling -> super sapling -> tree
# tree is full, super sapling is base+ half trunk
# sapling is base?
# seed and bud are same, just color random that matches full plant?
# actually seed is same always brown


experiment with drawing trunks of only the same length until past certain trunk num (i.e. height?)
trunk splits? just like branch splits, but allow for literally one or two...
initially pick subset of all possible rules according to say a type of tree? -> coniferous trees have smaler angles between successive trunks?
want probably smoother sections ... longer trunks and lesser pieces? or tons, small angle changes?

look into bezier.. generate trunks similarly save for now all yoou need is points? than draw bezier point by point by calculating paramteric rep. based on all points



ImageDraw.arc(xy, start, end, fill=None, width=0)
ImageDraw.chord(xy, start, end, fill=None, outline=None, width=1)
ImageDraw.ellipse(xy, fill=None, outline=None, width=1)
ImageDraw.pieslice(xy, start, end, fill=None, outline=None, width=1)
ImageDraw.point(xy, fill=None)
ImageDraw.rectangle(xy, fill=None, outline=N
one, width=1)
ImageDraw.text(xy, text, fill=None, font=None, anchor=None, spacing=4, align='left', direction=None, features=None, language=None, stroke_width=0, stroke_fill=None)
ImageDraw.line(xy, fill=None, width=0, joint=None) --> width is line width, joint can be "curve" for rounded line sequences


arc:
Draws an arc (a portion of a circle outline) between the start and end angles, inside the given bounding box.

Parameters
xy – Two points to define the bounding box. Sequence of [(x0, y0), (x1, y1)] or [x0, y0, x1, y1], where x1 >= x0 and y1 >= y0.

start – Starting angle, in degrees. Angles are measured from 3 o’clock, increasing clockwise.

end – Ending angle, in degrees.

fill – Color to use for the arc.

width –

The line width, in pixels.


chord:
Same as arc(), but connects the end points with a straight line.

Parameters
xy – Two points to define the bounding box. Sequence of [(x0, y0), (x1, y1)] or [x0, y0, x1, y1], where x1 >= x0 and y1 >= y0.

outline – Color to use for the outline.

fill – Color to use for the fill.

width –

The line width, in pixels.




bezier:
defined by succession of points, which "draw" the curve to themselves and create the curvature
examp for two points:
	p_0 + t(p_1 - p_0), set t to anyting to get point on curve, p_0 is actual first point, p_1 is actual second
general def:
	sum_i to n (choose(n,i)*(1-t)^(n-i)*t^(i)*p_i)
	so choose a bunch of points that are start and end points of trunks
	arrange in correct order
	then input to this function as data, and call function for t = 1 to 10, increasing by .01 or something... (figure out range)
	then take output points and plot as its own curve

